#include <unistd.h>
#include <assert.h>

#include <algorithm>
#include <functional>

#include "thr.h"


//==============================================================================
//==============================================================================
//==============================================================================
//=============== t_thr_task_base ==============================================


t_thr_task_base::t_thr_task_base(int task_id):
    p_begin_(NULL), p_end_(NULL), task_id_(task_id), fl_task_run_(false)
{
    int res = sem_init(&sem_stop_, 0, 0);
    assert(0 == res);
}

//==============================================================================

t_thr_task_base::~t_thr_task_base()
{   // Объект уничтожается основным потоком, заача не должна в это время исполняться
    assert(!fl_task_run_);
    int res = sem_destroy(&sem_stop_);
    assert(0 == res);
}

//==============================================================================

void t_thr_task_base::task_wait_4end()
{   /* Ждём завершения задачи по семафору.
     * Вызывается в управляющем потоке, который запускал задачу.
     * После возврата, основной поток вновь становится владельцем нашего объекта.
     */
    if(fl_task_run_) {
        int res = sem_wait(&sem_stop_);
        assert(0 == res); // TODO обработка ошибки, м.б. повторный вызов
        fl_task_run_ = false;
    }
}

//==============================================================================

void t_thr_task_base::send_2thr(t_thr &thr)
{   /* Постановка задачи в очередь указанному потоку, который её запустит.
     * Вызывается в управляющем потоке. Будет вызываться из ф-ции потомка,
     * которая предварительно инициализирует задачу.
     * После вызова владельцем объекта становится исполняющий поток,
     * управляющий поток может вызывать только task_wait_4end().
     */
    assert(!fl_task_run_);
    fl_task_run_ = true;
    sem_trywait(&sem_stop_); // На всякий случай, чтобы семафор был точно сброшен
    thr.thr_add_task(task_id_);
}

//==============================================================================

void t_thr_task_base::on_task_end()
{   /* Эту функцию необходимо вызвать из выполняющего потока, когда задача будет завершена,
     * после task_run_function(),
     * и с этого момента с объектом будет работать главный поток.
     * Просто отправляем семафор.
     */
    const int r = sem_post(&sem_stop_);
    assert(0 == r);
}


//==============================================================================
//==============================================================================
//==============================================================================
//=============== t_task_sort ==================================================


t_task_sort::t_task_sort(int task_id):
    t_thr_task_base(task_id)
{
}

//==============================================================================

t_task_sort::~t_task_sort()
{
}

//==============================================================================

void t_task_sort::start_sort(t_thr &thr, t_sortint *p_begin, t_sortint *p_end, bool fl_asc)
{   /* Отправляем задание в поток, на сортировку последовательности чисел
     * if(fl_asc) - то по возрастанию.
     * Если параметры не задают корректную последовательность, длиннее 1 элемента,
     * задание не отправится.
     */
    if(NULL != p_begin && NULL != p_end && p_end - p_begin > 1) {
        p_begin_ = p_begin;
        p_end_   = p_end;
        fl_asc_  = fl_asc;
        send_2thr(thr);
    }
}

//==============================================================================

void t_task_sort::task_run_function()
{   // Сортировка, выполняется при выполнении задания в потоке
    if(fl_asc_) {
        std::sort(p_begin_, p_end_);
    } else {
        std::sort(p_begin_, p_end_, std::greater<t_sortint>());
    }
}

//==============================================================================
//==============================================================================
//==============================================================================
//=============== t_thr ========================================================


t_thr::t_thr(t_vec_tasks &vec_tasks):
    fl_thr_active_(true), vec_tasks_(vec_tasks)
{   // Инициализируемся, и запускаем тред, который будет ждать заданий через fifo
    assert(vec_tasks.size() <= TASK_ID_STOP);
    int fd[2];
    int r = pipe(fd);
    assert(0 == r);
    fd_fifo_write_2thr_    = fd[1];
    fd_fifo_read_from_thr_ = fd[0];

    r = pthread_create(&thr_sys_id_, NULL, thr_sys_run_function, this);
    assert(0 == r);
}

//==============================================================================

t_thr::~t_thr()
{
    if(fl_thr_active_) {
        thr_stop();
    }

    close(fd_fifo_write_2thr_);
    close(fd_fifo_read_from_thr_);
}

//==============================================================================

void t_thr::thr_add_task(int task_id)
{   // Отправляем задание в очередь потока. Вызывается из главного потока.
    assert(task_id < vec_tasks_.size() || TASK_ID_STOP == task_id);
    uint8_t id8 = task_id;
    const int r = write(fd_fifo_write_2thr_, &id8, 1);
    assert(1 == r);
}

//==============================================================================

void t_thr::thr_stop()
{   // Из главного потока, посылаем в очередь нашего потока команду остановки.
    // Поток остановится, когда выполнит все более ранние задания. Ждём остановки.
    thr_add_task(TASK_ID_STOP);
    pthread_join(thr_sys_id_, NULL);
    fl_thr_active_ = false;
}

//==============================================================================

void *t_thr::thr_sys_run_function(void *arg)
{   // Функция для pthread_create
    reinterpret_cast<t_thr *>(arg)->thr_internal_run_function();
    return NULL;
}

//==============================================================================

void t_thr::thr_internal_run_function()
{   // Главная функция работы потока. Ждёт заданий и исполняет их.
    while(true) {
        uint8_t id8;
        const int r = read(fd_fifo_read_from_thr_, &id8, 1);
        assert(1 == r);

        if(TASK_ID_STOP == id8) {
            break;
        }

        auto p_task = vec_tasks_.at(id8);
        p_task->task_run_function();
        p_task->on_task_end();
    }
}
